<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AVLTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cent2</a> &gt; <a href="index.source.html" class="el_package">bomb.tools.data.structures.avl</a> &gt; <span class="el_source">AVLTree.java</span></div><h1>AVLTree.java</h1><pre class="source lang-java linenums">package bomb.tools.data.structures.avl;

import java.util.List;

/**
 *
 * @param &lt;E&gt;
 */
public class AVLTree&lt;E extends Comparable&lt;E&gt;&gt; {
    /**
     *
     * @param &lt;E&gt;
     */
    static class Node&lt;E&gt;{
        private final E element;
        private short balanceFactor;
        private final String value;
        private Node&lt;E&gt; left, right;

<span class="fc" id="L20">        Node(E element, String value){</span>
<span class="fc" id="L21">            this.element = element;</span>
<span class="fc" id="L22">            this.value = value;</span>
<span class="fc" id="L23">            balanceFactor = 0;</span>
<span class="fc" id="L24">            left = right = null;</span>
<span class="fc" id="L25">        }</span>

        boolean isLeaf(){
<span class="fc bfc" id="L28" title="All 4 branches covered.">            return left == null &amp;&amp; right == null;</span>
        }
    }

    private Node&lt;E&gt; root;

    /**
     *
     */
<span class="fc" id="L37">    public AVLTree(){</span>
<span class="fc" id="L38">        root = null;</span>
<span class="fc" id="L39">    }</span>

    /**
     *
     *
     * @param initArray
     * @param values
     * @throws UnbalancedEntriesException
     */
<span class="nc" id="L48">    public AVLTree(E[] initArray, String[] values) throws UnbalancedEntriesException {</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        if (initArray.length == values.length) {</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">            for (int i = 0; i &lt; initArray.length; i++)</span>
<span class="nc" id="L51">                addNode(initArray[i], values[i]);</span>
<span class="nc" id="L52">        } else throw new UnbalancedEntriesException(initArray.length, values.length);</span>
<span class="nc" id="L53">    }</span>

    /**
     *
     * @param list
     * @param values
     * @throws UnbalancedEntriesException
     */
<span class="nc" id="L61">    public AVLTree(List&lt;E&gt; list, String[] values) throws UnbalancedEntriesException {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (list.size() == values.length){</span>
            @SuppressWarnings(&quot;Unchecked cast&quot;)
<span class="nc" id="L64">            E[] array = (E[]) list.toArray();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            for (int i = 0; i&lt; values.length; i++)</span>
<span class="nc" id="L66">                addNode(array[i], values[i]);</span>
<span class="nc" id="L67">        } else throw new UnbalancedEntriesException(list.size(), values.length);</span>
<span class="nc" id="L68">    }</span>

    /**
     *
     * @param element
     * @param value
     */
    public void addNode(E element, String value){
<span class="fc" id="L76">        root = addNode(element, value, root);</span>
<span class="fc" id="L77">        root = rescale(root);</span>
<span class="fc" id="L78">    }</span>

    /**
     *
     * @param element
     * @param value
     * @param stem
     * @return
     * @throws IllegalArgumentException
     */
    private Node&lt;E&gt; addNode(E element, String value, Node&lt;E&gt; stem)
            throws IllegalArgumentException {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (stem == null) return new Node&lt;&gt;(element, value);</span>

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (element.compareTo(stem.element) == 0)</span>
<span class="nc" id="L93">            throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        else if (element.compareTo(stem.element) &lt; 0)</span>
<span class="nc" id="L95">            stem.left = addNode(element, value, stem.left);</span>
        else
<span class="fc" id="L97">            stem.right = addNode(element, value, stem.right);</span>
<span class="fc" id="L98">        return stem;</span>
    }

    /**
     *
     * @param stem
     * @return
     */
    private Node&lt;E&gt; rescale(Node&lt;E&gt; stem){
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (stem.isLeaf()) {</span>
<span class="fc" id="L108">            stem.balanceFactor = 0;</span>
<span class="fc" id="L109">            return stem;</span>
        }

<span class="fc" id="L112">        stem.balanceFactor = tiltScale(stem);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (notNull(stem.left)) stem.left = rescale(stem.left);</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (notNull(stem.right)) stem.right = rescale(stem.right);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (Math.abs(stem.balanceFactor) &gt; 1) stem = algorithm(stem);</span>

<span class="fc" id="L117">        return stem;</span>
    }

    /**
     *
     * @param stem
     * @return
     */
    private short tiltScale(Node&lt;E&gt; stem){
<span class="fc" id="L126">        return (short) (height(stem.right) - height(stem.left));</span>
    }

    /**
     *
     * @param stem
     * @return
     */
    private Node&lt;E&gt; algorithm(Node&lt;E&gt; stem){
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (stem.balanceFactor &gt; 1){</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            stem = (stem.right.balanceFactor &gt; 0)?</span>
<span class="pc" id="L137">                    doubleRight(stem): //Stem BF is 2 and Stem.right is positive - RR Tree</span>
<span class="pc" id="L138">                    rightLeft(stem); //Stem BF is 2 and Stem.right is negative - RL Tree</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        } else if (stem.balanceFactor &lt; -1){</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            stem = (stem.left.balanceFactor &lt; 0)?</span>
<span class="pc" id="L141">                    doubleLeft(stem): //Stem BF is 2 and Stem.left is negative - LL Tree</span>
<span class="fc" id="L142">                    leftRight(stem); //Stem BF is 2 and Stem.left is positive - LR Tree</span>
        }
<span class="fc" id="L144">        return stem;</span>
    }

    /**
     *
     * @param search
     * @return
     */
    public String dig(E search){
<span class="fc" id="L153">        return digDug(search, root);</span>
    }

    /**
     *
     * @param search
     * @param stem
     * @return
     */
    private String digDug(E search, Node&lt;E&gt; stem){
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (search.equals(stem.element)) return stem.value;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (stem.isLeaf()) return null;</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">        return search.compareTo(stem.element) &lt; 0 ?</span>
<span class="nc" id="L167">                digDug(search, stem.left) :</span>
<span class="nc" id="L168">                digDug(search, stem.right);</span>
    }

    /**
     *
     */
    public void traverse(){
<span class="nc" id="L175">        System.out.println(traversePreOrder(root));</span>
<span class="nc" id="L176">    }</span>

    /**
     *
     * @param root
     * @return
     */
    private String traversePreOrder(Node&lt;E&gt; root) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (root == null) return &quot;&quot;;</span>

<span class="nc" id="L186">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L187">        sb.append(root.value);</span>

<span class="nc" id="L189">        String pointerRight = &quot;â””â”€â”€&quot;;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        String pointerLeft = (notNull(root.right)) ? &quot;â”œâ”€â”€&quot; : &quot;â””â”€â”€&quot;;</span>

<span class="nc" id="L192">        traverseNodes(sb, &quot;&quot;, pointerLeft, root.left, notNull(root.right));</span>
<span class="nc" id="L193">        traverseNodes(sb, &quot;&quot;, pointerRight, root.right, false);</span>

<span class="nc" id="L195">        return sb.toString();</span>
    }

    /**
     *
     * @param sb
     * @param padding
     * @param pointer
     * @param node
     * @param hasRightSibling
     */
    private void traverseNodes(StringBuilder sb, String padding, String pointer, Node&lt;E&gt; node,
                               boolean hasRightSibling) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (notNull(node)) {</span>
<span class="nc" id="L209">            sb.append(&quot;\n&quot;);</span>
<span class="nc" id="L210">            sb.append(padding);</span>
<span class="nc" id="L211">            sb.append(pointer);</span>
<span class="nc" id="L212">            sb.append(node.value);</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">            String paddingForBoth = padding + (hasRightSibling ? &quot;â”‚  &quot; : &quot;   &quot;);</span>
<span class="nc" id="L215">            String pointerRight = &quot;â””â”€â”€&quot;;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            String pointerLeft = (notNull(node.right)) ? &quot;â”œâ”€â”€&quot; : &quot;â””â”€â”€&quot;;</span>

<span class="nc" id="L218">            traverseNodes(sb, paddingForBoth, pointerLeft, node.left, notNull(node.right));</span>
<span class="nc" id="L219">            traverseNodes(sb, paddingForBoth, pointerRight, node.right, false);</span>
        }
<span class="nc" id="L221">    }</span>

    /**
     *
     * @return
     */
    public int getTotalHeight(){
<span class="fc" id="L228">        return height(root);</span>
    }

    /**
     *
     * @param stem
     * @return
     */
    private int height(Node&lt;E&gt; stem) {
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (!notNull(stem)) return 0;</span>
<span class="fc" id="L238">        return 1 + Math.max(height(stem.left), height(stem.right));</span>
    }

    /**
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; doubleLeft(Node&lt;E&gt; root){
<span class="nc" id="L247">        return rotateRight(root);</span>
    }

    /**
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; doubleRight(Node&lt;E&gt; root){
<span class="fc" id="L256">        return rotateLeft(root);</span>
    }

    /**
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; leftRight(Node&lt;E&gt; root){
<span class="fc" id="L265">        root.left = rotateLeft(root.left);</span>
<span class="fc" id="L266">        return rotateRight(root);</span>
    }

    /**
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; rightLeft(Node&lt;E&gt; root){
<span class="nc" id="L275">        root.right = rotateRight(root.right);</span>
<span class="nc" id="L276">        return rotateLeft(root);</span>
    }

    /**
     *
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; rotateRight(Node&lt;E&gt; root){
<span class="fc" id="L286">        Node&lt;E&gt; temp = root.left;</span>
<span class="fc" id="L287">        root.left = temp.right;</span>
<span class="fc" id="L288">        temp.right = root;</span>
<span class="fc" id="L289">        return temp;</span>
    }

    /**
     *
     * @param root
     * @return
     */
    private Node&lt;E&gt; rotateLeft(Node&lt;E&gt; root) {
<span class="fc" id="L298">        Node&lt;E&gt; temp = root.right;</span>
<span class="fc" id="L299">        root.right = temp.left;</span>
<span class="fc" id="L300">        temp.left = root;</span>
<span class="fc" id="L301">        return temp;</span>
    }

    /**
     *
     * @param stem
     * @return
     */
    private boolean notNull(Node&lt;E&gt; stem){
<span class="fc bfc" id="L310" title="All 2 branches covered.">        return stem != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>