<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HexComparator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Cent2</a> &gt; <a href="index.source.html" class="el_package">bomb.tools.hexalgorithm</a> &gt; <span class="el_source">HexComparator.java</span></div><h1>HexComparator.java</h1><pre class="source lang-java linenums">package bomb.tools.hexalgorithm;

import bomb.tools.data.structures.FixedArrayQueue;

import java.util.ArrayList;

/**
 * The class contains the necessary methods to compare the defuser vision (HexGrid) to the full Maze
 * and find a section that matches the HexGrid based on the defuser's shape locations.
 * The methods use for loops to simulate the stencil from the interactive Hexamaze site assuming the
 * stencil starts in the top left, iterates down the first set of columns, moves over a row and repeats.
 */
public class HexComparator {

    /**
     * Don't let anyone instantiate this class
     */
    private HexComparator(){}

    /**
     * Scans the entire maze to see where the defuser's HexGrid is
     *
     * @param fullMaze The entire maze known to the expert only
     * @param grid The defuser's vision
     * @return A hexagon containing the wall information for each node in the defuser's vision
     * @throws IllegalArgumentException Any Exception that appears
     */
    public static HexGrid evaluate(Maze fullMaze, HexGrid grid) throws IllegalArgumentException {
<span class="nc" id="L29">        return evaluateSize(fullMaze, grid);</span>
    }

    /**
     * Checks that the HexGrid is smaller than the actual maze
     *
     * @param fullMaze The full maze
     * @param grid The 2D iterator
     * @return The grid or null whether it's found
     * @throws IllegalArgumentException The side length exceeds the size the maze
     */
    private static HexGrid evaluateSize(Maze fullMaze, HexGrid grid) throws IllegalArgumentException{
<span class="nc bnc" id="L41" title="All 2 branches missed.">        if (grid.sideLength() &lt; fullMaze.exportTo2DQueue().cap())</span>
<span class="nc" id="L42">            return solve(fullMaze, grid);</span>
<span class="nc" id="L43">        throw new IllegalArgumentException(&quot;Side Length requested exceeds the size of the Maze&quot;);</span>
    }

    /**
     *
     *
     * @param fullMaze The full maze
     * @param grid The 2D iterator
     * @return The grid or null whether it's found
     * @throws IllegalArgumentException If there's a size difference between the two hexagons
     */
    private static HexGrid solve(Maze fullMaze, HexGrid grid) throws IllegalArgumentException{
        //TODO - Break down
<span class="nc" id="L56">        int[] spans = getSpans(fullMaze, grid);</span>
        FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower;
<span class="nc" id="L58">        HexGrid match = null;</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        for(int xOffset = 0; xOffset &lt;= (spans[0] - spans[1]); xOffset++){</span>
<span class="nc" id="L60">            tower = getTower(fullMaze, spans[1], xOffset);</span>
<span class="nc" id="L61">            tower = shaveProtocol(tower,</span>
<span class="nc" id="L62">                    fullMaze.hexport().sideLength() - (grid.sideLength() + xOffset), grid);</span>
<span class="nc" id="L63">            int[] pings = pingRequest(grid.sideLength());</span>
<span class="nc" id="L64">            match = identifyMatch(new Hex(startHexagon(pings, tower), grid.sideLength()),</span>
                    tower, grid, pings);
<span class="nc bnc" id="L66" title="All 2 branches missed.">            if (match != null) xOffset = spans[0];</span>
        }
<span class="nc" id="L68">        return match;</span>
    }

    /**
     * Returns the spans of the maze and the grid hexagons
     *
     * @param fullMaze The full maze
     * @param grid The 2D iterator
     * @return The array of spans
     */
    private static int[] getSpans(Maze fullMaze, HexGrid grid){
<span class="nc" id="L79">        return new int[]{fullMaze.hexport().getSpan(), grid.hexport().getSpan()};</span>
    }

    /**
     *
     *
     * @param fullMaze The full maze
     * @param gridSpan The span of the grid
     * @param offset The offset representing the column to start taking from
     * @return A section of the maze used for
     */
    private static FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; getTower(Maze fullMaze, int gridSpan, int offset){
<span class="nc" id="L91">        FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; rawNodes = fullMaze.exportTo2DQueue(),</span>
<span class="nc" id="L92">                outputTower = new FixedArrayQueue&lt;&gt;(gridSpan);</span>
        //TODO - Streamable?
<span class="nc bnc" id="L94" title="All 2 branches missed.">        for (int i = offset; i &lt; (gridSpan + offset); i++)</span>
<span class="nc" id="L95">            outputTower.add(deepCopyList(rawNodes.get(i)));</span>
<span class="nc" id="L96">        return outputTower;</span>
    }

    private static FixedArrayQueue&lt;Hex.HexNode&gt; deepCopyList(FixedArrayQueue&lt;Hex.HexNode&gt; input){
        //TODO - Streamable?
<span class="nc" id="L101">        FixedArrayQueue&lt;Hex.HexNode&gt; output = new FixedArrayQueue&lt;&gt;(input.cap());</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        for (int i = 0; i &lt; output.cap(); i++)</span>
<span class="nc" id="L103">            output.add(new Hex.HexNode(input.get(i)));</span>
<span class="nc" id="L104">        return output;</span>
    }

    /**
     *
     *
     * @param tower The section of the full maze
     * @param shaveCap The number determining how much to shave off the top of certain lists
     * @param grid The 2D iterator
     * @return The shaven hex tower
     */
    private static FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; shaveProtocol
            (FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower, int shaveCap, HexGrid grid){
<span class="nc bnc" id="L117" title="All 2 branches missed.">        return shaveCap &lt; 0 ?</span>
<span class="nc" id="L118">                firstHalfShave(tower, Math.abs(shaveCap), grid) :</span>
<span class="nc" id="L119">                secondHalfShave(tower, shaveCap, grid);</span>
    }

    /**
     *
     *
     * @param tower The set of columns taken from the full maze
     * @param shaveCap The number determining how much to shave off the top of certain lists
     * @param grid The 2D iterator
     * @return The trimmed down hexagonal tower
     */
    private static FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; firstHalfShave
            (FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower, int shaveCap, HexGrid grid){
<span class="nc" id="L132">        int cap = absCap(shaveCap, grid);</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (int col = 0; col &lt; grid.sideLength() - 1; col++)</span>
<span class="nc" id="L135">            tower.get(col).removeFromHead(calculateCap(cap, col, grid));</span>
<span class="nc" id="L136">        return tower;</span>
    }

    /**
     *
     *
     * @param cap The number determining how much to shave off the top of certain lists
     * @param colIndex
     * @param grid The 2D iterator
     * @return The number of elements to shave off the top of the lists
     */
    private static int calculateCap(int cap, int colIndex, HexGrid grid){
<span class="nc" id="L148">        int min = Math.min(cap, grid.sideLength() - ++colIndex);</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        return (min == 1 || min == 2) ? min : grid.sideLength() - colIndex;</span>
    }

    /**
     * Trims down elements from the columns in the second half of the hexagon
     *
     * @param tower The set of columns taken from the full maze
     * @param shaveCap The number determining how much to shave off the top of certain lists
     * @param grid The 2D iterator
     * @return The trimmed down hexagonal tower
     */
    private static FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; secondHalfShave
            (FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower, int shaveCap, HexGrid grid){
<span class="nc" id="L162">        int cap = absCap(shaveCap, grid), removalCounter = 1;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        for (int col = grid.sideLength(); col &lt; grid.hexport().getSpan(); col++)</span>
<span class="nc" id="L164">            tower.get(col).removeFromHead(Math.min(cap, removalCounter++));</span>
<span class="nc" id="L165">        return tower;</span>
    }

    /**
     *
     *
     * @param shaveCap
     * @param grid
     * @return
     */
    private static int absCap(int shaveCap, HexGrid grid){
<span class="nc" id="L176">        int gridCap = grid.sideLength() - 1;</span>
<span class="nc" id="L177">        return Math.min(gridCap, shaveCap);</span>
    }

    /**
     * Creates an array of lengths corresponding to the columns of the 2D iterator
     *
     * @param sideLength The side length of the hexagon
     * @return An array of column lengths
     */
    static int[] pingRequest(int sideLength) {
<span class="nc" id="L187">        int counter = 0;</span>
<span class="nc" id="L188">        int[] request = new int[2 * sideLength - 1];</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        for (int i = sideLength; i &lt; 2 * sideLength; i++)</span>
<span class="nc" id="L191">            request[counter++] = i;</span>


<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (int j = 2 * sideLength - 2; j &gt;= sideLength; j--)</span>
<span class="nc" id="L195">            request[counter++] = j;</span>

<span class="nc" id="L197">        return request;</span>
    }

    /**
     *
     *
     * @param pings
     * @param tower
     * @return
     */
    private static FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; startHexagon
            (int[] pings, FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower){
<span class="nc" id="L209">        FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; outputHexagon = new FixedArrayQueue&lt;&gt;(pings.length);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (int x = 0; x &lt; pings.length; x++){</span>
<span class="nc" id="L211">            FixedArrayQueue&lt;Hex.HexNode&gt; inputColumn = new FixedArrayQueue&lt;&gt;(pings[x]);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (int y = 0; y &lt; pings[x]; y++)</span>
<span class="nc" id="L213">                inputColumn.add(tower.get(x).get(y));</span>
<span class="nc" id="L214">            outputHexagon.add(inputColumn);</span>
        }
<span class="nc" id="L216">        return outputHexagon;</span>
    }

    /**
     *
     *
     * @param startingGrid The 2D iterator
     * @param tower
     * @param grid The grid that the defuser sees
     * @param pings
     * @return
     * @throws IllegalArgumentException If there's a size difference between the two hexagons
     */
    private static HexGrid identifyMatch(Hex startingGrid, FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower,
                                         HexGrid grid, int[] pings) throws IllegalArgumentException{
<span class="nc" id="L231">        int rotations = fullRotationCompare(grid, startingGrid);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (rotations != -1)</span>
<span class="nc" id="L233">            return new HexGrid(startingGrid, rotations);</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">        while (pings[grid.sideLength() - 1] != tower.get(grid.sideLength() - 1).size()){</span>
<span class="nc" id="L236">            startingGrid = nextTo(pings, startingGrid, tower);</span>
<span class="nc" id="L237">            rotations = fullRotationCompare(grid, startingGrid);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (rotations != -1)</span>
<span class="nc" id="L239">                return new HexGrid(startingGrid, rotations);</span>
<span class="nc" id="L240">            incrementArray(pings);</span>
        }

<span class="nc" id="L243">        return null;</span>
    }


    /**
     * Compares the HexGrid to the Hex containing nodes copied from the full Maze.
     * It does this 6 times, once for each time rotated
     *
     * @param grid The original defuser grid
     * @param copy The maze-copies set of HexNodes
     * @return True for a match, false for no match
     * @throws IllegalArgumentException If there's a size difference between the two hexagons
     */
    private static int fullRotationCompare(HexGrid grid, Hex copy) throws IllegalArgumentException{
<span class="nc" id="L257">        boolean result = false;</span>
<span class="nc" id="L258">        int counter = 0;</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">        while (counter &lt; 6 &amp;&amp; !result) {</span>
<span class="nc" id="L260">            result = compare(grid, copy);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (!result){</span>
<span class="nc" id="L262">                counter++;</span>
<span class="nc" id="L263">                copy.rotate(); //The copy has to fit the grid</span>
            }
        }
<span class="nc bnc" id="L266" title="All 2 branches missed.">        return counter != 6 ? counter : -1;</span>
    }

    /**
     * Compares the HexGrid to the Hex containing nodes copied from the full Maze once.
     *
     * @param grid The original defuser grid
     * @param copy The maze-copies set of HexNodes
     * @return True for a match, false for no match
     * @throws IllegalArgumentException If there's a size difference between the two hexagons
     */
    private static boolean compare(HexGrid grid, Hex copy) throws IllegalArgumentException{
<span class="nc" id="L278">        ArrayList&lt;Hex.HexNode&gt; gridArray = grid.hexport().exportToList(),</span>
<span class="nc" id="L279">                copyArray = copy.exportToList();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (gridArray.size() != copyArray.size())</span>
<span class="nc" id="L281">            throw new IllegalArgumentException(&quot;Size Difference in compare()&quot;);</span>

        //TODO - Streamable?
<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (int i = 0; i &lt; gridArray.size(); i++)</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (gridArray.get(i).fill != copyArray.get(i).fill) return false;</span>
<span class="nc" id="L286">        return true;</span>
    }

    /**
     * Rotates the resulting Hex to be in the correct position
     *
     * @param copy The Hexagon duplicate
     * @param rotations The number of rotations the Hexagon needs to go through
     * @return The rotated hexagon
     */
    private static Hex rotateTo(Hex copy, int rotations){
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int i = 0; i &lt; rotations; i++) copy.rotate();</span>
<span class="nc" id="L298">        return copy;</span>
    }

    /**
     * Increments each number in the array
     *
     * @param array The array of integers
     */
    private static void incrementArray(int[] array){
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (int idx = 0; idx &lt; array.length; idx++) array[idx] += 1;</span>
<span class="nc" id="L308">    }</span>

    /**
     * Cuts off the first elements of the Hexagon and adds next set
     *
     * @param pings The indices of the next set
     * @param grid The previous Hexagon
     * @param tower The full columns to take from
     * @return The next Hexagon to test
     */
    private static Hex nextTo(int[] pings, Hex grid, FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower){
<span class="nc" id="L319">        FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; rawHex = grid.exportTo2DQueue();</span>
<span class="nc" id="L320">        shaveTop(rawHex);</span>
<span class="nc" id="L321">        appendTo(pings, rawHex, tower);</span>
<span class="nc" id="L322">        return new Hex(rawHex, grid.sideLength());</span>
    }

    /**
     * Cuts off the first elements of each column
     *
     * @param grid The previous Hexagon
     */
    private static void shaveTop(FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; grid){
        //TODO - Streamable?
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (int i = 0; i &lt; grid.cap(); i++)</span>
<span class="nc" id="L333">            grid.get(i).removeFromHead(1);</span>
<span class="nc" id="L334">    }</span>

    /**
     * Adds the next set of elements to the columns
     *
     * @param pings The locations of the next elements to access
     * @param grid The previous Hexagon
     * @param tower The set of columns to take from
     */
    private static void appendTo(int[] pings, FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; grid,
                                 FixedArrayQueue&lt;FixedArrayQueue&lt;Hex.HexNode&gt;&gt; tower){
        //TODO - Streamable?
<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (int i = 0; i &lt; grid.size(); i++)</span>
<span class="nc" id="L347">            grid.get(i).add(tower.get(i).get(pings[i]));</span>
<span class="nc" id="L348">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>